
有哪些适合新手练手的Python项目
https://zhuanlan.zhihu.com/p/22164270

https://www.zhihu.com/question/29372574/answer/88624507


http://study.163.com/course/courseMain.htm?courseId=378003

课时34  丰富的else语句及简洁的with语句
with 可以在异常时很好用 不用关闭

== 36 ==
36 类和对象：给大家介绍对

继chen
In [1]: class Mylist(list):
   ...:     pass
   ...: 

In [2]: list2 = Mylist()

In [3]: list2.append(5)

In [4]: list2.append(3)

In [5]: list2
Out[5]: [5, 3]

In [6]: list2.sort()
In [7]: list2
Out[7]: [3, 5]


多态
In [8]: class A:
   ...:     def fun(self):
   ...:         print ("我是 小a'''")
   ...:         
In [9]: class B:
   ...:     def fun(self):
   ...:         print("我是小b''")
   ...:         

In [10]: a = A()
In [11]: b = B()

In [12]: a.fun()
我是 小a'''
In [13]: b.fun()
我是小b''


==37 类和对象：面向对象编程==

#!/usr/bin/python
#-*- coding:utf-8 -*-
class Ball:
    def setName(self,name):
        self.name = name
    def kick(self):
#        print("%s"  % self.name)
#        pass
        print("我叫%s,该死的谁踢我'''" % self.name)

a = Ball()
a.setName=('球a')
a.name
#b = Ball()
#b.setName=('球b')
#c = Ball()
#c.setName=('土豆')
a.kick()
#pass



Traceback (most recent call last):
  File "ball.py", line 13, in <module>
    a.name
AttributeError: Ball instance has no attribute 'name'

但是在ipython ok 


n [2]: class Ball:
   ...:     def setName(self,name):
   ...:         self.name = name
   ...:     def kick(self):
   ...:         print("我叫%s,该死的谁踢我'''" % self.name)
   ...:         

In [3]: a = Ball()

In [4]: a.setName('ball a')

In [5]: a.kick()
我叫ball a,该死的谁踢我'''

In [6]: b = Ball()

In [7]: b.setName('ball b')

In [8]: c = Ball()

In [9]: c.setName('土豆')

In [10]: c.kick()
我叫土豆,该死的谁踢我'''


******************
魔术方法之__init__
In [11]: class Ball:
    ...:     def __init__(self,name):
    ...:         self.name = name
    ...:     def kick(self):
    ...:         print("我叫%s,该死的谁踢我'''" % self.name)
    ...:         

In [12]: b = Ball('土豆')

In [13]: b.kick()
我叫土豆,该死的谁踢我'''

In [14]: c = Ball()

TypeError: __init__() takes exactly 2 arguments (1 given)

*************
公有 私有

In [15]: class Person:
    ...:     name = "evan"
    ...:     
In [16]: p=Person()

In [17]: p.name
Out[17]: 'evan'


私有变量 

In [18]: class Person:
    ...:     __name = "evan"
    ...:     
    ...:     

In [19]: p=Person()

In [20]: p.__name
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-20-5fe22c1da0df> in <module>()
----> 1 p.__name
AttributeError: Person instance has no attribute '__name'

怎么办呢 从内部

In [21]: class Person:
    ...:     __name = "evan"
    ...:     def getName(self):
    ...:         return self.__name
    ...:      

In [22]: p=Person()

In [23]: p.getName()
Out[23]: 'evan'

p.__name 还是不能直接用
但是可以作弊
In [25]: p._Person__name
Out[25]: 'evan'

==38 ==
类和对象：继承

In [1]: class Parent:
   ...:     def hello(self):
   ...:         print("正在调用父类的方法")

In [3]: class Child(Parent):
   ...:     pass


In [4]: p = Parent()

In [5]: p.hello()
正在调用父类的方法

In [6]: c = Child()

In [7]: c.hello()
正在调用父类的方法


同名的情况下 子类会覆盖父类

In [8]: class  Child(Parent):
   ...:     def hello(self):
   ...:         print("正在调用子类的方法'''")
   ...:         

In [9]: c = Child()

In [10]: c.hello()
正在调用子类的方法'''

In [11]: p.hello()
正在调用父类的方法


对于 同名的情况下 子类会覆盖父类 处理办法
1.调用未绑定的父类方法


2.使用supper function(这个方法更加好)
super().__init__()

===多重继承===

class Base1:
    def foo1(self):
        print("I am  foo1, I wei Base1 daiyan")

class Base2:
    def foo2(self):
        print("I am foo2, I wei  Base2 daiyan")
class C(Base1,Base2):
    pass

c = C()
c.foo1()
c.foo2()

注意了 这是基于py3.3的

== 39 类和对象：拾遗==
类 类对象和实例对象

In [1]: class C:
   ...:     count = 0
   ...:     

In [2]: a = C()

In [3]: b = C()

In [4]: c = C()

In [5]: a.count
Out[5]: 0

In [6]: b.count
Out[6]: 0

In [7]: c.count
Out[7]: 0


In [14]: c.count = 10

In [15]: c.count
Out[15]: 10

In [16]: a.count
Out[16]: 0

In [17]: C.count
Out[17]: 0

In [18]: C.count += 100

In [19]: a.count
Out[19]: 100

In [20]: c.count
Out[20]: 10


In [21]: class C:
    ...:     def x(self):
    ...:         print("x=man")
    ...:         

In [22]: c =C()

In [23]: c.x()
x=man

In [24]: c.x =  1

In [25]: c.x
Out[25]: 1

In [26]: c.x()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-26-54c1306e95b7> in <module>()
----> 1 c.x()

TypeError: 'int' object is not callable

由上可以看到 如果属性和方法同名 属性会 覆盖方法
****

绑定 
python 严格要求方法需要有实例才能被调用，这限制其实就是py所谓的绑定概念

错误举例
In [28]: class BB:
    ...:     def printBB():
    ...:         print("no zuo no die")
    ...:         

#有可能可以打印 
In [29]: BB.printBB()

In [31]: bb = BB()

In [32]: BB.printBB()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-32-8541405c8d5c> in <module>()
----> 1 BB.printBB()

TypeError: unbound method printBB() must be called with BB instance as first argument (got nothing instead)


In [33]: class CC:
    ...:     def setXY(self, x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def printXY(self):
    ...:         print(self.x, self.y)
    ...:         

In [34]: dd = CC()
In [36]: dd.__dict__
Out[36]: {}

In [37]: CC.__dict__
Out[37]: 
{'__doc__': None,
 '__module__': '__main__',
 'printXY': <function __main__.printXY>,
 'setXY': <function __main__.setXY>}


In [38]: dd.setXY(4,5)

In [39]: dd.__dict__
Out[39]: {'x': 4, 'y': 5}
在dd里面有 而在 CC  __dict__ 里面没有 只属于实例对象dd

In [40]: del CC

In [41]: ee = CC()
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-41-b626c5c9f95d> in <module>()
----> 1 ee = CC()

NameError: name 'CC' is not defined

实例对象的还存在的 因为类属性和方法是静态的 一直在内存中 直到程序退出
In [43]: dd.printXY()
(4, 5)

以上就是讲了绑定的概念  尽量不要类属性 而是使用实例属性

==40 类和对象：一些相关的BIF==

In [44]: class A:
    ...:     pass
    ...: 
In [47]: class B(A):
    ...:     pass
    ...: 

In [48]: issubclass(B,A)
Out[48]: True

In [49]: issubclass(B,B)
Out[49]: True

#如果py3 为True
In [50]: issubclass(B,object)
Out[50]: False

In [51]: class C:
    ...:     pass
    ...: 

In [52]: issubclass(B,C)
Out[52]: False



isinstance(object,classinfo)

In [53]: b1 = B()

In [54]: isinstance(b1,B)
Out[54]: True
## B 类来自A类
In [55]: isinstance(b1,A)
Out[55]: True

In [57]: isinstance(b1,C)
Out[57]: False


In [58]: isinstance(b1,(A,B,C))
Out[58]: True

*****
hasattr(object,name)

In [59]: class C:
    ...:     def __init__(self,x=0):
    ...:         self.x = x
    ...:         

In [60]: c1 = C()

In [61]: hasattr(c1,'x')
Out[61]: True

In [62]: hasattr(c1,x)
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-62-83051dc9a513> in <module>()
----> 1 hasattr(c1,x)

NameError: name 'x' is not defined


***

这个记得很久以前看py教程时有的
getattr(object,name[,default])

In [63]: getattr(c1,'x')
Out[63]: 0

In [64]: getattr(c1,'y')
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-64-9fc2adeb1eb0> in <module>()
----> 1 getattr(c1,'y')

AttributeError: C instance has no attribute 'y'

In [65]: getattr(c1,'y','not attr is y')
Out[65]: 'not attr is y'


setattr(object,name, value)

In [66]: setattr(c1,'y','evan')

In [67]: getattr(c1,'y','not attr is y')
Out[67]: 'evan'

***
delattr(objcect,name)

In [68]: delattr(c1,'y')

In [69]: delattr(c1,'y')
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-69-23149f9e774e> in <module>()
----> 1 delattr(c1,'y')

AttributeError: C instance has no attribute 'y'


******
属性设置属性？
property(fget=None,fset=None, fdel=None,doc=None)

In [70]: class c:
    ...:     def __init__(self,size=10):
    ...:         self.size = size
    ...:     def getSize(self):
    ...:         return self.size
    ...:     def setSize(self):
    ...:         self.size = value
    ...:     def delSize(self):
    ...:         del self.size
    ...:     x = property(getSize,setSize,delSize)

In [73]: c1 = c()

In [74]: c1.getSize()
Out[74]: 10

In [75]: c1.x
Out[75]: 10

In [76]: c1.x = 18

In [77]: c1.x
Out[77]: 18

20170815
到12分出错没看下去 




09


==chatper 11 魔法方法==

===41.魔法方法:构造和析构===

魔法方法总是被双下划线包围 eg __init__

__init__(self[,])   返回值得一定是None  其实就是 别的语言的构造方法

注意了 其实实例化时调用的第一个方法 是 __new__(cls[, ...]) 

In [83]: class Rectangle:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def getPeri(self):
    ...:         return (self.x + self.y) *2
    ...:     def getArea(self):
    ...:         return self.x * self.y
    ...:     

In [84]: rect = Rectangle(3,4)

In [85]: rect.getPeri()
Out[85]: 14

In [86]: rect.getArea()
Out[86]: 12

t.getArea()
543Out[86]: 12



In [89]: class CapStr(str):
    ...:     def __new__(cls,string):
    ...:         string = string.upper()
    ...:         return str.__new__(cls,string)

In [90]: a = CapStr("I love evan.com")

In [91]: a
Out[91]: 'I LOVE EVAN.COM'

由上可见 在改变一下不可变的对象 例如 str 时，就可以 改写一下 


***
__del__(self)

In [92]: class C:
    ...:     def __init__(self):
    ...:         print ("I am __init__")
    ...:     def __del__(self):
    ...:         print ("I am __del__")
    ...:         

In [93]: c1 = C()
I am __init__

In [94]: c2 = c1
In [95]: c3 = c2
In [96]: del c3
In [97]: del c2
In [98]: del c1
I am __del__


== 42.魔法方法：算术运算==

对于现在来说
可见 所谓的工厂function 就是类对象

>>> type(dir)
<class 'builtin_function_or_method'>
>>> type(int)
<class 'type'>


>>> class C:
...     pass
... 
>>> type(C)
<class 'type'>



evan@evanpc:~/github/python/allpynotes$ cat sub.py
class New_int(int):
    def __add__(self,other):
        return int.__sub__(self,other)
    def __sub__(self,other):
        return int.__add__(self,other)

a = New_int(3)    
b = New_int(5)
print a+b
print a - b

"""


-2
8

a --> self  b -->other
故意a +b  其实是a 减去b
"""

== 43.魔法方法：算术运算2==

In [1]: class int(int):
   ...:     def __add__(self,other):
   ...:         return int.__sub__(self,other)
   ...:     

In [2]: a = int('5')
In [3]: a
Out[3]: 5

In [4]: b = int(3)
In [5]: a + b 
Out[5]: 2


此时 self is a  other is  b 
那只有一个参数的 a 呢 


反运算 

06:00


奇怪的
In [6]: class Nint(int):
   ...:     def __radd__(self,other):
   ...:         return int.__sub__(self,other)
   ...:     

In [7]: a = Nint(5)

In [8]: b = Nint(3)

In [9]: a+b
Out[9]: 2

In [10]: a + b 
Out[10]: 2


看看视频 再看书 真的理解得更加快快 

10:00


Python print函数用法，print 格式化输出
http://www.pythonclub.org/python-basic/print#dokuwiki__top

****************************************

Python资料推荐 + IDE推荐+经典练手项目（开源免费）~
http://www.jianshu.com/p/d9fc43995fde

分分钟学会一门语言之Python篇
http://www.code123.cc/1049.html

Python快速教程
http://www.cnblogs.com/vamei/archive/2012/09/13/2682778.html

学习Python在Linux运维上的应用应该看哪些书 、什么样的学习路线
https://www.zhihu.com/question/25955197

运维人员学习python 推荐资料
https://blog.imdst.com/yun-wei-xue-pythontui-jian-shu-ji/

http://www.chinaunix.net/ops/

python
https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/

 Linux服务器如何自定义安装Redis
http://blog.csdn.net/xiexieliuyi/article/details/51124215


