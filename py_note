
以下为Python命令行参数：
选项	描述
-d	在解析时显示调试信息


但是，要定义一个只有1个元素的tuple，如果你这么定义：

>>> t = (1)
>>> t
1
定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。

所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：

>>> t = (1,)
>>> t
(1,)
Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。


使用list和tuple







******************
条件判断和循环

条件判断
elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>


循环

sum = 0
for x in range(101):
    sum = sum + x
print sum


第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。

再议raw_input

最后看一个有问题的条件判断。很多同学会用raw_input()读取用户的输入，这样可以自己输入，程序运行得更有意思：

birth = raw_input('birth: ')
if birth < 2000:
    print '00前'
else:
    print '00后'
输入1982，结果却显示00后，这么简单的判断Python也能搞错？

当然不是Python的问题，在Python的交互式命令行下打印birth看看：

>>> birth
'1982'
>>> '1982' < 2000
False
>>> 1982 < 2000
True
原因找到了！原来从raw_input()读取的内容永远以字符串的形式返回，把字符串和整数比较就不会得到期待的结果，必须先用int()把字符串转换为我们想要的整型：

birth = int(raw_input('birth: '))



使用dict和set

===dict===

In [1]: d = { 'evan':95, 'bob':77, 'tr':88}

In [2]: d['evan']
Out[2]: 95



把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：

>>> d['Adam'] = 67
>>> d['Adam']
67

由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

如果key不存在，dict就会报错：

要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：

>>> 'Thomas' in d
False

二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：

>>> d.get('Thomas')
>>> d.get('Thomas', -1)
-1
注意：返回None的时候Python的交互式命令行不显示结果。


要删除一个key，用pop(key)方法，对应的value也会从dict中删除
In [6]: d.pop('bob')
Out[6]: 77


需要牢记的第一条就是dict的key必须是不可变对象。

这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：

>>> key = [1, 2, 3]
>>> d[key] = 'a list'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'


===set===
set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

要创建一个set，需要提供一个list作为输入集合：

要创建一个set，需要提供一个list作为输入集合：

>>> s = set([1, 2, 3])
>>> s
set([1, 2, 3])

注意，传入的参数[1, 2, 3]是一个list，而显示的set([1, 2, 3])只是告诉你这个set内部有1，2，3这3个元素，显示的[]不表示这是一个list。 但是用ipython 没这个[] 

通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：

通过remove(key)方法可以删除元素：

set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：

set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。

===再议不可变对象===
上面我们讲了，str是不变对象，而list是可变对象。

对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：

>>> a = ['c', 'b', 'a']
>>> a.sort()
>>> a
['a', 'b', 'c']

而对于不可变对象，比如str，对str进行操作呢：

>>> a = 'abc'
>>> a.replace('a', 'A')
'Abc'
>>> a
'abc'

虽然字符串有个replace()方法，也确实变出了'Abc'，但变量a最后仍是'abc'，应该怎么理解呢？


所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
小结

使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。

tuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。


==函数==


数据类型转换

Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：

函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：
>>> a = abs # 变量a指向abs函数
>>> a(-1) # 所以也可以通过a调用abs函数
1



===定义函数===
在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。

In [3]: def my_abs(x):
   ...:     if x >= 0:
   ...:         return x
   ...:     else:
   ...:         return -x 
   ...:     

In [4]: my_abs(-20)
Out[4]: 20

请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。
如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。
return None可以简写为return。


===空函数===

如果想定义一个什么事也不做的空函数，可以用pass语句：
def nop():
    pass
pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。

pass还可以用在其他语句里，比如：
if age >= 18:
    pass
缺少了pass，代码运行就会有语法错误。



===参数检查===
如果参数类型不对，Python解释器就无法帮我们检查

我们定义的my_abs没有参数检查，所以，这个函数定义不够完善。
让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance实现：

def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x


===返回多个值===
函数可以返回多个值吗？答案是肯定的
但其实这只是一种假象，Python函数返回的仍然是单一值：

>>> r = move(100, 100, 60, math.pi / 6)
>>> print r
(151.96152422706632, 70.0)

原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。


小结

定义函数时，需要确定函数名和参数个数；

如果有必要，可以先对参数的数据类型做检查；

函数体内部可以用return随时返回函数结果；

函数执行完毕也没有return语句时，自动return None。

函数可以同时返回多个值，但其实就是一个tuple。


==函数的参数==
===默认参数===

从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：

一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；

二是如何设置默认参数。

当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

使用默认参数有什么好处？最大的好处是能降低调用函数的难度。


默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：


先定义一个函数，传入一个list，添加一个END再返回：

def add_end(L=[]):
    L.append('END')
    return L

当你正常调用时，结果似乎不错：

>>> add_end([1, 2, 3])
[1, 2, 3, 'END']
>>> add_end(['x', 'y', 'z'])
['x', 'y', 'z', 'END']

当你使用默认参数调用时，一开始结果也是对的：
In [9]: add_end()
Out[9]: ['END']


但是，再次调用add_end()时，结果就不对了：
In [10]: add_end()
Out[10]: ['END', 'END']


很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。

原因解释如下：

Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。
所以，定义默认参数要牢记一点：默认参数必须指向不变对象！


要修改上面的例子，我们可以用None这个不变对象来实现：
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L

现在，无论调用多少次，都不会有问题：

>>> add_end()
['END']
>>> add_end()
['END']


为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。


===可变参数===
在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。


我们把函数的参数改为可变参数：

def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：




如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：

>>> nums = [1, 2, 3]
>>> calc(nums[0], nums[1], nums[2])
14

这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：

>>> nums = [1, 2, 3]
>>> calc(*nums)
14


===关键字参数===

可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：

n [1]: def person(name,age,**kw):
   ...:     print 'name:',name,'age:',age, 'other:',kw
   ...:     

函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：

In [2]: person('evan',30)
name: evan age: 30 other: {}


也可以传入任意个数的关键字参数：

>>> person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}

关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。

和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：

>>> kw = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=kw['city'], job=kw['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

当然，上面复杂的调用可以用简化的写法：

>>> kw = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **kw)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}



===参数组合===

在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。

比如定义一个函数，包含上述4种参数：

def func(a, b, c=0, *args, **kw):
    print 'a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw

在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。

>>> func(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
>>> func(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
>>> func(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
>>> func(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}

最神奇的是通过一个tuple和dict，你也可以调用该函数：

>>> args = (1, 2, 3, 4)
>>> kw = {'x': 99}
>>> func(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'x': 99}

所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。
小结

Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。

默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！

要注意定义可变参数和关键字参数的语法：

*args是可变参数，args接收的是一个tuple；

**kw是关键字参数，kw接收的是一个dict。

以及调用函数时如何传入可变参数和关键字参数的语法：

可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；

关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。

使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。



===递归函数===
In [4]: def fact(n):
   ...:     if n ==1:
   ...:         return 1
   ...:     return n*fact(n - 1)
   ...: 

In [5]: fact(1)
Out[5]: 1

In [6]: fact(5)
Out[6]: 120

In [7]: fact(100)
Out[7]: 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L


如果我们计算fact(5)，可以根据函数定义看到计算过程如下：

===> fact(5)
===> 5 * fact(4)
===> 5 * (4 * fact(3))
===> 5 * (4 * (3 * fact(2)))
===> 5 * (4 * (3 * (2 * fact(1))))
===> 5 * (4 * (3 * (2 * 1)))
===> 5 * (4 * (3 * 2))
===> 5 * (4 * 6)
===> 5 * 24
===> 120

递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。

遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。






小结

使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。

针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。

Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题




==高级特性==





构造一个1, 3, 5, 7, ..., 99的列表，可以通过循环实现：

In [1]: L = []
In [2]: n =1 
In [3]: while n <= 99:
   ...:     L.append(n)
   ...:     n = n +2 
   ...:     

In [4]: print L
[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]


===切片===

切片（Slice）操作符，能大大简化这种操作。
In [1]: L = ['evan','sara','Trac','bob','jack']

In [2]: L[0:3]
Out[2]: ['evan', 'sara', 'Trac']

如果第一个索引是0，还可以省略：
>>> L[:3]
['Michael', 'Sarah', 'Tracy']

也可以从索引1开始，取出2个元素出来：
n [3]: L[1:3]
Out[3]: ['sara', 'Trac']

类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试
In [4]: L[-2:]
Out[4]: ['bob', 'jack']

In [5]: L[-2:-1]
Out[5]: ['bob']

记住倒数第一个元素的索引是-1。

切片操作十分有用。我们先创建一个0-99的数列：
>>> L = range(100)
>>> L
[0, 1, 2, 3, ..., 99]

可以通过切片轻松取出某一段数列。比如前10个数：
In [8]: L[:10]
Out[8]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

后10个数：
In [9]: L[-10:]
Out[9]: [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]

前11-20个数：
In [10]: L[11:20]
Out[10]: [11, 12, 13, 14, 15, 16, 17, 18, 19]

In [11]: L[11:21]
Out[11]: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

前10个数，每两个取一个：
In [12]: L[:10:2]
Out[12]: [0, 2, 4, 6, 8]

所有数，每5个取一个：
In [13]: L[::5]
Out[13]: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]

甚至什么都不写，只写[:]就可以原样复制一个list：
>>> L[:]
[0, 1, 2, 3, ..., 99]

tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：
In [15]: (0,1,2,3,4,5)[:3]
Out[15]: (0, 1, 2)

In [16]: A=(0,1,2,3,4,5)

In [17]: A[:3]
Out[17]: (0, 1, 2)


字符串'xxx'或Unicode字符串u'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：
In [18]: 'ABCDEFG'[:3]
Out[18]: 'ABC'

In [19]: 'ABCDEFG'[::2]
Out[19]: 'ACEG'

在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。
小结

有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。

==迭代==
=== ===
如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。

在Python中，迭代是通过for ... in来完成的

可以看出，Python的for循环抽象程度要高于Java的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。

list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：

In [20]: d = {'a':1,'b':2,'c':3}

In [21]: for key in d:
    ...:     print key 
    ...:     
a
c
b

因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样

默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems()。

由于字符串也是可迭代对象，因此，也可以作用于for循环：
In [22]: for ch in 'ABC':
    ...:     print ch
    ...:     
A
B
C

所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。

那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：

In [23]: from collections import Iterable

In [24]: isinstance('abc',Iterable)
Out[24]: True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False


如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：

In [1]: for i,value in enumerate(['A','B','C']):
   ...:     print i,value
   ...:     
0 A
1 B
2 C


上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：

>>> for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print x, y
...
1 1
2 4
3 9

小结

任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。

==列表生成式==

列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。

举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用range(1, 11)：

range(1,11)

生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：
In [2]: range(1,11)
Out[2]: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

In [3]: L = []

In [4]: for x in range(1,11):
   ...:     L.append(x * x)
   ...:     

In [5]: L
Out[5]: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

#

In [6]: [x * x for x in range(1,11)]
Out[6]: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]



还可以使用两层循环，可以生成全排列：
In [7]: [m + n for m in 'ABC' for n in 'XYZ']
Out[7]: ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']

运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：
In [8]: import os 

In [9]: [d for d in os.listdir('.')]  #os.listdir可以列出文件和目录
Out[9]: 
['instant_markup',
 'src20',
 '\xe6\x80\xbb\xe7\xbb\x93',
 'mysql_connect',
 'class',

for循环其实可以同时使用两个甚至多个变量，比如dict的iteritems()可以同时迭代key和value：
In [10]: d = {'x':'A', 'y':'B','z':'c'}

In [11]: for k, v in d.iteritems():
    ...:     print k,'=',v
    ...:     
y = B
x = A
z = c


因此，列表生成式也可以使用两个变量来生成list：
In [12]: d = {'x':'A', 'y':'B','z':'c'}

In [13]: [k + '=' + v for k,v in d.iteritems()]
Out[13]: ['y=B', 'x=A', 'z=c']

最后把一个list中所有的字符串变成小写：
In [14]: L=['Hello','WORD']

In [15]: [s.lower() for s in L]
Out[15]: ['hello', 'word']

小结

运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。

思考：如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，所以列表生成式会报错：

>>> L = ['Hello', 'World', 18, 'Apple', None]
>>> [s.lower() for s in L]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'int' object has no attribute 'lower'

使用内建的isinstance函数可以判断一个变量是不是字符串：

>>> x = 'abc'
>>> y = 123
>>> isinstance(x, str)
True
>>> isinstance(y, str)
False

请修改列表生成式，通过添加if语句保证列表生成式能正确地执行。

==生成器==
如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。

要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：

In [21]: L = [x * x for x in range(10)]
In [22]: L
Out[22]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
In [23]: g = (x * x for x in range(10))

In [24]: g
Out[24]: <generator object <genexpr> at 0x7fe146a794b0>

创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。
我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？
如果要一个一个打印出来，可以通过generator的next()方法：

In [26]: g.next()
Out[26]: 0

In [27]: g.next()
Out[27]: 1

In [28]: g.next()
Out[28]: 4

generator保存的是算法，每次调用next()，就计算出下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。
当然，上面这种不断调用next()方法实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：

In [29]: g = (x * x for x in range(10))

In [30]: for n in g:
    ...:     print n 
    ...:     
0
1
4
9
16
25
36
49
64
81

所以，我们创建了一个generator后，基本上永远不会调用next()方法，而是通过for循环来迭代它。
generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现

比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：
1, 1, 2, 3, 5, 8, 13, 21, 34, ...
斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：
In [31]: def fib(max):
    ...:     n,a,b = 0,0,1
    ...:     while n < max:
    ...:         print b 
    ...:         a, b = b, a + b
    ...:         n =  n +1
    ...:         

In [32]: fib(6)
1
1
2
3
5
8

仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。

也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print b改为yield b就可以了：

In [35]: def fib(max):
    ...:     n , a ,b = 0, 0, 1
    ...:     while n < max:
    ...:         yield  b 
    ...:         a, b = b , a+b
    ...:         n = n +1
    ...:         

这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：

In [36]: fib(6)
Out[36]: <generator object fib at 0x7fe1459cc140>

最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。

In [37]: def odd():
    ...:     print 'step 1'
    ...:     yield 1
    ...:     print 'step 2'
    ...:     yield 3
    ...:     print 'step 3'
    ...:     yield 5
    ...:     

In [38]: o= odd()

In [39]: o.next()
step 1
Out[39]: 1

In [40]: o.next()
step 2
Out[40]: 3

In [41]: o.next()
step 3
Out[41]: 5

In [42]: o.next()
ERROR:root:Internal Python error in the inspect module.
Below is the traceback from this internal error.

可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next()就报错。

回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。

同样的，把函数改成generator后，我们基本上从来不会用next()来调用它，而是直接使用for循环来迭代：

>>> for n in fib(6):
...     print n
...
1
1
2
3
5
8

结

generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。

要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束




==函数式编程==

函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。
函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言

===高阶函数===

====变量可以指向函数====
如果只写abs呢？

>>> abs
<built-in function abs>
可见，abs(-10)是函数调用，而abs是函数本身。
要获得函数调用结果，我们可以把结果赋值给变量：
>>> x = abs(-10)
>>> x
10

但是，如果把函数本身赋值给变量呢？
>>> f = abs
>>> f
<built-in function abs>
结论：函数本身也可以赋值给变量，即：变量可以指向函数。


说明变量f现在已经指向了abs函数本身。

==== 函数名也是变量====
那么函数名是什么呢？函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！
如果把abs指向其他对象，会有什么情况发生？
>>> abs = 10
>>> abs(-10)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'int' object is not callable
把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数了！
当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。
注：由于abs函数实际上是定义在__builtin__模块中的，所以要让修改abs变量的指向在其它模块也生效，要用__builtin__.abs = 10。

====传入函数====
既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
一个最简单的高阶函数：
def add(x, y, f):
    return f(x) + f(y)
当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：
x ==> -5
y ==> 6
f ==> abs
f(x) + f(y) ==> abs(-5) + abs(6) ==> 11
用代码验证一下：
>>> add(-5, 6, abs)
11
编写高阶函数，就是让函数的参数能够接收别的函数。

小结
把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。


===map/reduce===

Python内建了map()和reduce()函数。

====map====

In [43]: def f(x):
    ...:     return x * x
    ...: 

In [44]: map(f,[1,2,3,4,5,6,7,8,9])
Out[44]: [1, 4, 9, 16, 25, 36, 49, 64, 81]

map()传入的第一个参数是f，即函数对象本身。

所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：
>>> map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])
['1', '2', '3', '4', '5', '6', '7', '8', '9']
只需要一行代码。

====reduce====
reduce ( 把…分解)把一个函数作用在一个序列[x1, x2, x3...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

比方说对一个序列求和，就可以用reduce实现：
In [45]: def add(x,y):
    ...:     return x + y
    ...: 

In [46]: reduce(add,[1,3,5,7,9])
Out[46]: 25
当然求和运算可以直接用Python内建函数sum()，没必要动用reduce。

但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场

In [47]: def fn(x,y):
    ...:     return x * 10 + y
    ...: 

In [48]: reduce(fn,[1,3,5,7,9])
Out[48]: 13579

这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：


不太明白
>>> def fn(x, y):
...     return x * 10 + y
...
>>> def char2num(s):
...     return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
...
>>> reduce(fn, map(char2num, '13579'))
13579

整理成一个str2int的函数就是：

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))

还可以用lambda函数进一步简化成：

def char2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2int(s):
    return reduce(lambda x,y: x*10+y, map(char2num, s))

也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！



===filter===
Python内建的filter()函数用于过滤序列。

和map()类似，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

例如，在一个list中，删掉偶数，只保留奇数，可以这么写：

In [49]: def is_odd(n):
    ...:     return n % 2 == 1
    ...: 

In [50]: filter(is_odd,[1,2,4,5,6,9,10,15])
Out[50]: [1, 5, 9, 15]

把一个序列中的空字符串删掉，可以这么写：
In [51]: def not_empty(s):
    ...:     return s and s.strip()
    ...: 

In [52]: filter(not_empty,['A','','B',None,'C', ''])
Out[52]: ['A', 'B', 'C']

=== sorted ===
==== 排序算法 ====

排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x < y，则返回-1，如果认为x == y，则返回0，如果认为x > y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。


In [53]: sorted([36,5,8])
Out[53]: [5, 8, 36]


# return -1  就排在前面么 
此外，sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。比如，如果要倒序排序，我们就可以自定义一个reversed_cmp函数：

def reversed_cmp(x, y):
    if x > y:
        return -1
    if x < y:
        return 1
    return 0

传入自定义的比较函数reversed_cmp，就可以实现倒序排序：

>>> sorted([36, 5, 12, 9, 21], reversed_cmp)
[36, 21, 12, 9, 5]


=== 返回函数===

==== 函数作为返回值 ====
高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：

n [54]: def calc_sum(*args):
    ...:     ax = 0
    ...:     for n in args:
    ...:         ax = ax + n 
    ...:     return ax 
    ...: 

n [57]: calc_sum(1,2)
Out[57]: 3

但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！

In [58]: def lazy_sum(*args):
    ...:     def sum():
    ...:         ax = 0
    ...:         for n in args:
    ...:             ax = ax +n 
    ...:         return ax
    ...:     return sum 
    ...: 

当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：

In [59]: f = lazy_sum(1,3,5,7,9)

In [60]: f
Out[60]: <function __main__.sum>

调用函数f时，才真正计算求和的结果：
In [62]: f()
Out[62]: 25

在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。

请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：

>>> f1 = lazy_sum(1, 3, 5, 7, 9)
>>> f2 = lazy_sum(1, 3, 5, 7, 9)
>>> f1==f2
False

f1()和f2()的调用结果互不影响。


====闭包====
注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs
f1, f2, f3 = count()
在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。
你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：
>>> f1()
9
>>> f2()
9
>>> f3()
9
全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。
返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
In [73]: def count():
    ...:      fs = []
    ...:      for i in range(1, 4):
    ...:          def f(j):
    ...:              def g():
    ...:                  return j*j
    ...:              return g
    ...:          fs.append(f(i))
    ...:      return fs
    ...:  
In [74]: f1, f2, f3 = count()
In [75]: f1()
Out[75]: 1
In [76]: f3()
Out[76]: 9



=== 匿名函数===
当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。

在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：
In [1]: map(lambda x: x * x,[1,2,3,4,5,6,7,8,9])
Out[1]: [1, 4, 9, 16, 25, 36, 49, 64, 81]

通过对比可以看出，匿名函数lambda x: x * x实际上就是：

def f(x):
    return x * x

关键字lambda表示匿名函数，冒号前面的x表示函数参数。

匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：
In [2]: f = lambda x: x * x
In [3]: f
Out[3]: <function __main__.<lambda>>
In [4]: f(5)
Out[4]: 25

同样，也可以把匿名函数作为返回值返回，比如：
In [5]: def build(x,y):
   ...:     return lambda: x * x + y*y


=== 装饰器 ===
由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。
In [7]: def now():
   ...:     print '2017-03-30'

In [8]: f = now 
In [9]: f()
2017-03-30

函数对象有一个__name__属性，可以拿到函数的名字
In [10]: now.__name__
Out[10]: 'now'

In [11]: f.__name__
Out[11]: 'now'

现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。
本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：
==== 知识回顾====
既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
一个最简单的高阶函数：
def add(x, y, f):
    return f(x) + f(y)
当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：
x ==> -5
y ==> 6
f ==> abs
f(x) + f(y) ==> abs(-5) + abs(6) ==> 11
用代码验证一下：
>>> add(-5, 6, abs)
11



In [12]: def log(func):
    ...:     def wrapper(*args,**kw):
    ...:         print 'call %s():' % func.__name__
    ...:         return func(*args,**kw)
    ...:     return wrapper
    ...: 

In [15]: @log
    ...: def now():
    ...:     print '2017-03-30'
    ...:     

调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：
In [16]: now()
call now():
2017-03-30

把@log放到now()函数的定义处，相当于执行了语句：

now = log(now)

由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。





































******************************
devops
我也是从别人那偷师。现在的互联网公司尤其重视DevOps，很多大公司内部都用Python写自动化运维工具，我也发现用Python实现自动化打包、部署、测试非常方便，朋友推荐我去看廖雪峰老师的Python教程，两周学下来，基本上就能写自动化脚本了。”

“而且这个部署的网页也是用Python写的，我用了Flask框架，两天就搭好了。后台调用Fabric自动部署，现在我们都不用登SSH再用跳板机手动敲命令了。”

http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000
